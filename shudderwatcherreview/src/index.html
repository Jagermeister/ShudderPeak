<html>
<head>
    <title>Watcher Review</title>
    <script src='./chart.js' type='text/javascript'></script>
    <script src='./utility.js' type='text/javascript'></script>
</head>
<body style="background-color: #201029; color: #FFF;">
    <table>
        <tr>
            <td>
                <video width="720"></video>
            </td>
            <td width="360">
                <table>
                    <tr>
                        <td>
                            <div style="display: inline-table;" id="timelineHighlight"></div>
                        </td>
                        <td>
                            <button onclick="videoElement.play()">PLAY</button>
                            <button onclick="videoElement.pause(); clearTimeout(highlightTimeoutId);">PAUSE</button>
                            <br />
                            <button onclick="videoElement.playbackRate = 3.0;">3X</button>
                            <button onclick="videoElement.playbackRate = 1.0;">1X</button>
                            <button onclick="videoElement.playbackRate = 0.5;">.5X</button>
                            <br />
                            <button onclick="playHighlights()">Highlights</button>
                        </td>
                    </tr>
                </table>
            </td>
        </tr>
    </table>
    <div id="canvasContainer"></div>
    <script type="text/javascript">
        'use strict';
        const loadingPromises = [];
        const timelineHighlight = document.getElementById("timelineHighlight");
        const videoElement = document.querySelector("video");

        const canvas_width = 1080,
            canvas_height = 450;
        const canvas = utility.canvasCreate("canvasContainer", "hexBackground", { width: canvas_width + 20, height: canvas_height });
        const ctx = canvas.getContext("2d");

        const fontSize = 20;
        const charts = [];
        const keyDownEvents = {};

        const buckets = [];
        const bucket_duration_ms = 40000,
            bucket_duration_sec = bucket_duration_ms / 1000;

        let rawMessageData = null;
        const emoteKeys = new Set();
            
        let startTimeChatMS, endTimeChatMS,
            xDomainStart, xDomainEnd,
            currentMessageTime,
            startTimeSec;

        let videoMetaData;
        let highlightBuckets;
        let highlightTimeoutId;

        function init() {
            charts.push(new Chart({ x: 0, y: 0, width: canvas_width, height: 250 }));
            charts.push(new Chart({ x: 0, y: 250, width: canvas_width, height: 150 }));
            let messagesLoadedResolve;
            loadingPromises.push(
                new Promise((resolve, reject) => {
                    videoElement.addEventListener('loadeddata', (e) => {
                        resolve();
                    })
                })
            );
            loadingPromises.push(
                new Promise((resolve, reject) => {
                    messagesLoadedResolve = resolve;
                })
            );

            fetch('videos.json')
                .then(response => response.json())
                .then(videos => {
                    let video = videos.videos[1];
                    videoElement.setAttribute('src', './' + video.source);
                    return video;
                })
                .then(video => {
                    videoMetaData = video;
                    fetch(video.messages)
                        .then(response => response.json())
                        .then(messages => {
                            rawMessageData = messages;
                            currentMessageTime = xDomainStart = startTimeChatMS = +messages[0].time;
                            xDomainEnd = endTimeChatMS = +messages[messages.length - 1].time;
                            messagesLoadedResolve();
                        });
                })

            Promise.all(loadingPromises)
                .then(() => {
                    console.log("ALL PROMISES RESOLVED")
                    const videoStartTimeMS = new Date(videoMetaData.created_at).getTime();
                    const videoLength = videoMetaData.length;
                    const videoDuration = videoElement.duration;

                    const chatVideoSyncDiffSec = ((startTimeChatMS - videoStartTimeMS) / 1000);
                    const chatVideoSyncTime = videoDuration + (chatVideoSyncDiffSec - videoLength);
                    videoElement.currentTime = startTimeSec = chatVideoSyncTime;

                    const maxChatTime = startTimeChatMS + (videoLength - chatVideoSyncDiffSec) * 1000;
                    xDomainEnd = endTimeChatMS = endTimeChatMS > maxChatTime ? maxChatTime : endTimeChatMS;
                    bucketsCreate();
                    chartsBuild();
                    display();
                });

            keyDownEvents[39] = () => timelineMoveForward();
            keyDownEvents[37] = () => timelineMoveBackward();

            ctx.font = fontSize + 'px Courier New';
            setInterval(() => {
                currentMessageTime = (videoElement.currentTime - startTimeSec) * 1000 + startTimeChatMS;
                if (!videoElement.paused) {
                    display();
                    updateTimelineHighlight();
                }
            }, 500)
        }

        function playHighlights() {
            const videoEndDateTime = new Date(videoMetaData.created_at).getTime() + videoMetaData.length * 1000;
            const videoRemainingTime = videoElement.duration - videoElement.currentTime;
            const videoCurrentDateTime = videoEndDateTime - videoRemainingTime * 1000;

            let closestBucket = highlightBuckets.map(b => b[2])
                .filter(b => videoCurrentDateTime < b.end);

            closestBucket = closestBucket ? closestBucket[0] : highlightBuckets[0];
            if (videoCurrentDateTime < closestBucket.start) {
                videoElement.currentTime = videoElement.duration - (videoEndDateTime - closestBucket.start) / 1000;
                currentMessageTime = closestBucket.start;
            }

            if (videoElement.paused) videoElement.play();
            highlightTimeoutId = setTimeout(playHighlights, 1000);
        }

        function xToTime(x) {
            const xPercentage = x / canvas_width;
            const domain = xPercentage * (xDomainEnd - xDomainStart) + xDomainStart
            return {
                percentage: xPercentage,
                domain: domain,
                video: ((domain - startTimeChatMS) / (endTimeChatMS - startTimeChatMS)) * (videoElement.duration - startTimeSec) + startTimeSec,
            };
        }

        function bucketsCreate(duration = bucket_duration_ms) {
            const bucketCreationStartTime = performance.now();
            buckets.length = 0;
            for (let t = xDomainStart; t <= xDomainEnd; t += duration) {
                buckets.push({
                    start: +t,
                    end: +t + duration,
                    users: new Set(),
                    emotes: {},
                    emotesNoSpam: {},
                    emoteCount: 0,
                    messages: 0
                });
            }

            let bucket = buckets[0];
            for (let i = 0, l = rawMessageData.length; i < l; i++) {
                const d = rawMessageData[i];
                if (d.time < bucket.start) {
                    continue;
                } else if (d.time > bucket.end) {
                    bucket = buckets.filter(b => b.start <= d.time && d.time < b.end)[0];
                }

                if (!bucket) {
                    break;
                }

                bucket.messages++;
                bucket.users.add(d.user);
                bucket.emoteCount += Object.keys(d.emotes).reduce((p, c) => p + d.emotes[c], 0);
                for (let key in d.emotes) {
                    emoteKeys.add(key);
                    bucket.emotes[key] = bucket.emotes[key] || 0;
                    bucket.emotes[key] += d.emotes[key];
                    bucket.emotesNoSpam[key] = bucket.emotesNoSpam[key] || 0;
                    bucket.emotesNoSpam[key]++;
                }
            }

            console.log('Bucket Creation Compute:', ((performance.now() - bucketCreationStartTime) / 1000 / 60).toFixed(2), 'seconds');
        }

        function chartsBuild() {
            const stats = seriesStats(buckets.map(b => b.messages));
            const mean = [],
                upper = [],
                upperupper = [];
            const bucketHistory = 12;
            for (let i = 0, l = buckets.length; i < l; i++) {
                const s = seriesStats(
                    buckets.slice((i-bucketHistory < 0) ? 0 : (i - bucketHistory), i+1)
                        .map(b => b.messages + b.emoteCount)
                );

                mean.push(s[0]);
                upper.push(s[0] + s[1]);
                upperupper.push(s[0] + s[1]+ s[1]);
            }

            charts[0].data = {
                0: buckets.map(b => b.messages),
                1: buckets.map(b => b.users.size),
                2: buckets.map(b => b.emoteCount),
                //3: buckets.map(b => b.messages + b.emoteCount),
                //10: buckets.map(b => stats[0]),
                //11: buckets.map(b => stats[0] + stats[1]),
                //4: mean,
                //6: upperupper,
            };

            charts[0].highlightBoxes = highlightBuckets = buckets.map((b, i) => [i, b.messages + b.emoteCount, b])
                .filter((b, i) => b[1] > upperupper[i]);

            let emoteLines = [];
            charts[1].data = {};
            Array.from(emoteKeys)
                .sort((a, b) =>
                    buckets.map(u => b in u.emotes ? u.emotes[b] : 0).reduce((p, c) => p + c, 0) - buckets.map(u => a in u.emotes ? u.emotes[a] : 0).reduce((p, c) => p + c, 0)
                )
                .forEach((k, i) => {
                    const arr = buckets.map(b => k in b.emotes ? b.emotes[k] : 0);
                    emoteLines.push(arr);
                    charts[1].data[i + '_' + k] = arr;
                }
                );
        }

        function seriesStats(values) {
            var mean = values.reduce((p, c) => p + c, 0) / values.length;
            //var median = values.slice().sort((a, b) => a - b)[Math.floor(values.length / 2)];

            var diffs = values.map(v => (v - mean) * (v - mean));
            var diffAvg = diffs.reduce((p, c) => p + c, 0) / diffs.length;
            var stDev = Math.sqrt(diffAvg)

            /*var mdiffs = values.map(v => (v - median) * (v - median));
            var mdiffAvg = mdiffs.reduce((p, c) => p + c, 0) / mdiffs.length;
            var mstDev = Math.sqrt(mdiffAvg)*/

            return [mean, stDev];

            const vMin = Math.min(...values);
            const vMax = Math.max(...values)
            console.log('Count', 'Min', 'Max', 'Mean', 'StDev');
            console.log(values.length, vMin, vMax, mean, stDev);
            console.log('Below', 'Within', 'Above');

            const below = values.filter(v => v < (mean - stDev)).length;
            const above = values.filter(v => v > (mean + stDev)).length;
            console.log(below, values.length - (below + above), above);
        }

        function updateTimelineHighlight() {
            const start = currentMessageTime - bucket_duration_ms / 2,
                end = currentMessageTime + bucket_duration_ms / 2;

            const timeRangeData = rawMessageData.filter(d => d.time >= start && d.time < end);

            let messages = 0,
                users = new Set(),
                emoteCount = 0,
                emotes = {},
                emotesNoSpam = {};
            for (let i = 0, l = timeRangeData.length; i < l; i++) {
                const d = timeRangeData[i];
                messages++;
                users.add(d.user);
                emoteCount += Object.keys(d.emotes).reduce((p, c) => p + d.emotes[c], 0);
                for (let key in d.emotes) {
                    emotes[key] = emotes[key] || 0;
                    emotes[key] += d.emotes[key];
                    emotesNoSpam[key] = emotesNoSpam[key] || 0;
                    emotesNoSpam[key]++;
                }
            }

            timelineHighlight.innerHTML = `
                <span style="background-color: ${utility.colors[0]};">Messages</span>: ${messages}<br/>
                <span style="background-color: ${utility.colors[1]};">Users</span>: ${users.size}<br/>
                <span style="background-color: ${utility.colors[2]};">Images</span>: ${emoteCount}<br/>
                TOP IMAGES:<br/>
                ${Object.keys(emotes)
                    .map(k => [k, emotes[k], emotesNoSpam[k]])
                    .sort((a, b) => a[1] - b[1])
                    .map(e => e[1] + ' <img height="45" src="./images/' + e[0] + '.png"/><br/>')
                    .slice(-4)
                    .reverse()
                    .join('')}
            `;
        }

        function timelineMoveBackward() {
            const sec = bucket_duration_sec / 2,
                ms = bucket_duration_ms / 2;
            if (videoElement.currentTime - sec < startTimeSec) {
                videoElement.currentTime = startTimeSec;
            } else {
                videoElement.currentTime -= sec;
            }

            if (currentMessageTime - ms < startTimeChatMS) {
                currentMessageTime = startTimeChatMS;
            } else {
                currentMessageTime -= ms;
            }

            display();
            updateTimelineHighlight();
        }

        function timelineMoveForward() {
            const sec = bucket_duration_sec / 2,
                ms = bucket_duration_ms / 2;
            if (videoElement.currentTime + sec > videoElement.duration) {
                videoElement.currentTime = videoElement.duration;
            } else {
                videoElement.currentTime += sec;
            }

            if (currentMessageTime + ms > endTimeChatMS) {
                currentMessageTime = endTimeChatMS;
            } else {
                currentMessageTime += ms;
            }

            display();
            updateTimelineHighlight();
        }

        canvas.addEventListener("mousedown", event => {
            const canvas_bounds = canvas.getBoundingClientRect();
            let y = event.clientY - canvas_bounds.top,
                x = event.clientX - canvas_bounds.left;

            const xTime = xToTime(x);

            videoElement.currentTime = xTime.video;
            currentMessageTime = xTime.domain;
            display();
            updateTimelineHighlight();
        });

        canvas.addEventListener('wheel', event => {
            const canvas_bounds = canvas.getBoundingClientRect();
            const y = event.clientY - canvas_bounds.top,
                x = event.clientX - canvas_bounds.left;
            const xTime = xToTime(x);
            const xDomainDuration = xDomainEnd - xDomainStart;

            if (event.deltaY < 0) {
                const minBucketsShown = 50;
                if (xDomainDuration == minBucketsShown * bucket_duration_ms) {
                    return
                }
                const newDuration = xDomainDuration * 0.75;
                if (newDuration < bucket_duration_ms * minBucketsShown) {
                    xDomainStart = xTime.domain - bucket_duration_ms * minBucketsShown / 2;
                    xDomainEnd = xTime.domain + bucket_duration_ms * minBucketsShown / 2;
                    if (xDomainStart < startTimeChatMS) {
                        xDomainStart = startTimeChatMS
                        xDomainEnd = startTimeChatMS + minBucketsShown * bucket_duration_ms;
                    } else if (xDomainEnd > endTimeChatMS) {
                        xDomainEnd = endTimeChatMS;
                        xDomainStart = xDomainEnd - minBucketsShown * bucket_duration_ms;
                    }
                } else {
                    xDomainStart = xTime.domain - newDuration * xTime.percentage;
                    xDomainEnd = xDomainStart + newDuration;
                }
            } else {
                const maxDuration = endTimeChatMS - startTimeChatMS
                if (xDomainDuration == maxDuration) {
                    return
                }
                const newDuration = xDomainDuration * 2;
                if (newDuration > maxDuration) {
                    xDomainStart = startTimeChatMS;
                    xDomainEnd = endTimeChatMS;
                } else {
                    xDomainStart = xTime.domain - newDuration * xTime.percentage;
                    xDomainEnd = xDomainStart + newDuration;
                    if (xDomainStart < startTimeChatMS) {
                        xDomainStart = startTimeChatMS
                        xDomainEnd = startTimeChatMS + newDuration;
                    } else if (xDomainEnd > endTimeChatMS) {
                        xDomainEnd = endTimeChatMS;
                        xDomainStart = xDomainEnd - newDuration;
                    }
                }
            }

            bucketsCreate()
            chartsBuild();
            display();

            return false;
        }, false);

        window.addEventListener("keydown", event => {
            let f = keyDownEvents[event.keyCode.toString()];
            if (f) { f(); }
        });

        function display() {
            ctx.clearRect(0, 0, canvas_width, canvas_height);

            ctx.fillStyle = 'rgba(240, 0, 0, 0.3)';
            let xVideoTimeStart = (currentMessageTime - xDomainStart - bucket_duration_ms / 2) / (xDomainEnd - xDomainStart) * canvas_width,
                xVideoTimeEnd = (currentMessageTime - xDomainStart + bucket_duration_ms / 2) / (xDomainEnd - xDomainStart) * canvas_width;

            if (xVideoTimeStart < 0) {
                xVideoTimeStart = 0;
            }
            if (xVideoTimeEnd > canvas_width) {
                xVideoTimeEnd = canvas_width;
            }
            ctx.fillRect(xVideoTimeStart, 0, xVideoTimeEnd - xVideoTimeStart, canvas_height);

            //ctx.beginPath();
            //const xVideoTime = (videoElement.currentTime - startTimeSec) / (videoElement.duration - startTimeSec) * canvas_width;
            //ctx.strokeStyle = 'red';
            //ctx.moveTo(xVideoTime, 0);
            //ctx.lineTo(xVideoTime, canvas_height);
            //ctx.stroke();

            for (let i = 0, l = charts.length; i < l; i++) {
                charts[i].display(ctx);
            }
        }

        window.onload = function () {
            init();
        }
    </script>
</body>

</html>